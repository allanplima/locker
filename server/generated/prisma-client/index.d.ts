// Code generated by Prisma (prisma@1.26.4). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  access: (where?: AccessWhereInput) => Promise<boolean>;
  log: (where?: LogWhereInput) => Promise<boolean>;
  session: (where?: SessionWhereInput) => Promise<boolean>;
  settings: (where?: SettingsWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  access: (where: AccessWhereUniqueInput) => AccessPromise;
  accesses: (args?: {
    where?: AccessWhereInput;
    orderBy?: AccessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Access>;
  accessesConnection: (args?: {
    where?: AccessWhereInput;
    orderBy?: AccessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AccessConnectionPromise;
  log: (where: LogWhereUniqueInput) => LogPromise;
  logs: (args?: {
    where?: LogWhereInput;
    orderBy?: LogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Log>;
  logsConnection: (args?: {
    where?: LogWhereInput;
    orderBy?: LogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LogConnectionPromise;
  session: (where: SessionWhereUniqueInput) => SessionPromise;
  sessions: (args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Session>;
  sessionsConnection: (args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SessionConnectionPromise;
  settingses: (args?: {
    where?: SettingsWhereInput;
    orderBy?: SettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Settings>;
  settingsesConnection: (args?: {
    where?: SettingsWhereInput;
    orderBy?: SettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SettingsConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAccess: (data: AccessCreateInput) => AccessPromise;
  updateAccess: (args: {
    data: AccessUpdateInput;
    where: AccessWhereUniqueInput;
  }) => AccessPromise;
  updateManyAccesses: (args: {
    data: AccessUpdateManyMutationInput;
    where?: AccessWhereInput;
  }) => BatchPayloadPromise;
  upsertAccess: (args: {
    where: AccessWhereUniqueInput;
    create: AccessCreateInput;
    update: AccessUpdateInput;
  }) => AccessPromise;
  deleteAccess: (where: AccessWhereUniqueInput) => AccessPromise;
  deleteManyAccesses: (where?: AccessWhereInput) => BatchPayloadPromise;
  createLog: (data: LogCreateInput) => LogPromise;
  updateLog: (args: {
    data: LogUpdateInput;
    where: LogWhereUniqueInput;
  }) => LogPromise;
  updateManyLogs: (args: {
    data: LogUpdateManyMutationInput;
    where?: LogWhereInput;
  }) => BatchPayloadPromise;
  upsertLog: (args: {
    where: LogWhereUniqueInput;
    create: LogCreateInput;
    update: LogUpdateInput;
  }) => LogPromise;
  deleteLog: (where: LogWhereUniqueInput) => LogPromise;
  deleteManyLogs: (where?: LogWhereInput) => BatchPayloadPromise;
  createSession: (data: SessionCreateInput) => SessionPromise;
  updateSession: (args: {
    data: SessionUpdateInput;
    where: SessionWhereUniqueInput;
  }) => SessionPromise;
  updateManySessions: (args: {
    data: SessionUpdateManyMutationInput;
    where?: SessionWhereInput;
  }) => BatchPayloadPromise;
  upsertSession: (args: {
    where: SessionWhereUniqueInput;
    create: SessionCreateInput;
    update: SessionUpdateInput;
  }) => SessionPromise;
  deleteSession: (where: SessionWhereUniqueInput) => SessionPromise;
  deleteManySessions: (where?: SessionWhereInput) => BatchPayloadPromise;
  createSettings: (data: SettingsCreateInput) => SettingsPromise;
  updateManySettingses: (args: {
    data: SettingsUpdateManyMutationInput;
    where?: SettingsWhereInput;
  }) => BatchPayloadPromise;
  deleteManySettingses: (where?: SettingsWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  access: (
    where?: AccessSubscriptionWhereInput
  ) => AccessSubscriptionPayloadSubscription;
  log: (
    where?: LogSubscriptionWhereInput
  ) => LogSubscriptionPayloadSubscription;
  session: (
    where?: SessionSubscriptionWhereInput
  ) => SessionSubscriptionPayloadSubscription;
  settings: (
    where?: SettingsSubscriptionWhereInput
  ) => SettingsSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ThemePicker = "DARK" | "LIGHT";

export type AccessOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SessionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "operatingSystemName_ASC"
  | "operatingSystemName_DESC"
  | "operatingSystemVersion_ASC"
  | "operatingSystemVersion_DESC"
  | "browserName_ASC"
  | "browserName_DESC"
  | "browserVersion_ASC"
  | "browserVersion_DESC"
  | "fingerprint_ASC"
  | "fingerprint_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LogOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "operation_ASC"
  | "operation_DESC"
  | "resource_ASC"
  | "resource_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SettingsOrderByInput =
  | "theme_ASC"
  | "theme_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "enabled_ASC"
  | "enabled_DESC"
  | "hidden_ASC"
  | "hidden_DESC"
  | "totp_ASC"
  | "totp_DESC"
  | "emailVerified_ASC"
  | "emailVerified_DESC"
  | "password_ASC"
  | "password_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "profilePicture_ASC"
  | "profilePicture_DESC"
  | "birthday_ASC"
  | "birthday_DESC"
  | "crm_ASC"
  | "crm_DESC"
  | "eCrm_ASC"
  | "eCrm_DESC"
  | "signaturePath_ASC"
  | "signaturePath_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AccessWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AccessWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  userAssigned?: UserWhereInput;
  AND?: AccessWhereInput[] | AccessWhereInput;
  OR?: AccessWhereInput[] | AccessWhereInput;
  NOT?: AccessWhereInput[] | AccessWhereInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  enabled?: Boolean;
  enabled_not?: Boolean;
  hidden?: Boolean;
  hidden_not?: Boolean;
  totp?: Boolean;
  totp_not?: Boolean;
  emailVerified?: Boolean;
  emailVerified_not?: Boolean;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  profilePicture?: String;
  profilePicture_not?: String;
  profilePicture_in?: String[] | String;
  profilePicture_not_in?: String[] | String;
  profilePicture_lt?: String;
  profilePicture_lte?: String;
  profilePicture_gt?: String;
  profilePicture_gte?: String;
  profilePicture_contains?: String;
  profilePicture_not_contains?: String;
  profilePicture_starts_with?: String;
  profilePicture_not_starts_with?: String;
  profilePicture_ends_with?: String;
  profilePicture_not_ends_with?: String;
  birthday?: DateTimeInput;
  birthday_not?: DateTimeInput;
  birthday_in?: DateTimeInput[] | DateTimeInput;
  birthday_not_in?: DateTimeInput[] | DateTimeInput;
  birthday_lt?: DateTimeInput;
  birthday_lte?: DateTimeInput;
  birthday_gt?: DateTimeInput;
  birthday_gte?: DateTimeInput;
  access_every?: AccessWhereInput;
  access_some?: AccessWhereInput;
  access_none?: AccessWhereInput;
  crm?: String;
  crm_not?: String;
  crm_in?: String[] | String;
  crm_not_in?: String[] | String;
  crm_lt?: String;
  crm_lte?: String;
  crm_gt?: String;
  crm_gte?: String;
  crm_contains?: String;
  crm_not_contains?: String;
  crm_starts_with?: String;
  crm_not_starts_with?: String;
  crm_ends_with?: String;
  crm_not_ends_with?: String;
  eCrm?: String;
  eCrm_not?: String;
  eCrm_in?: String[] | String;
  eCrm_not_in?: String[] | String;
  eCrm_lt?: String;
  eCrm_lte?: String;
  eCrm_gt?: String;
  eCrm_gte?: String;
  eCrm_contains?: String;
  eCrm_not_contains?: String;
  eCrm_starts_with?: String;
  eCrm_not_starts_with?: String;
  eCrm_ends_with?: String;
  eCrm_not_ends_with?: String;
  signaturePath?: String;
  signaturePath_not?: String;
  signaturePath_in?: String[] | String;
  signaturePath_not_in?: String[] | String;
  signaturePath_lt?: String;
  signaturePath_lte?: String;
  signaturePath_gt?: String;
  signaturePath_gte?: String;
  signaturePath_contains?: String;
  signaturePath_not_contains?: String;
  signaturePath_starts_with?: String;
  signaturePath_not_starts_with?: String;
  signaturePath_ends_with?: String;
  signaturePath_not_ends_with?: String;
  settings?: SettingsWhereInput;
  sessions_every?: SessionWhereInput;
  sessions_some?: SessionWhereInput;
  sessions_none?: SessionWhereInput;
  logs_every?: LogWhereInput;
  logs_some?: LogWhereInput;
  logs_none?: LogWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface SettingsWhereInput {
  theme?: ThemePicker;
  theme_not?: ThemePicker;
  theme_in?: ThemePicker[] | ThemePicker;
  theme_not_in?: ThemePicker[] | ThemePicker;
  AND?: SettingsWhereInput[] | SettingsWhereInput;
  OR?: SettingsWhereInput[] | SettingsWhereInput;
  NOT?: SettingsWhereInput[] | SettingsWhereInput;
}

export interface SessionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  operatingSystemName?: String;
  operatingSystemName_not?: String;
  operatingSystemName_in?: String[] | String;
  operatingSystemName_not_in?: String[] | String;
  operatingSystemName_lt?: String;
  operatingSystemName_lte?: String;
  operatingSystemName_gt?: String;
  operatingSystemName_gte?: String;
  operatingSystemName_contains?: String;
  operatingSystemName_not_contains?: String;
  operatingSystemName_starts_with?: String;
  operatingSystemName_not_starts_with?: String;
  operatingSystemName_ends_with?: String;
  operatingSystemName_not_ends_with?: String;
  operatingSystemVersion?: String;
  operatingSystemVersion_not?: String;
  operatingSystemVersion_in?: String[] | String;
  operatingSystemVersion_not_in?: String[] | String;
  operatingSystemVersion_lt?: String;
  operatingSystemVersion_lte?: String;
  operatingSystemVersion_gt?: String;
  operatingSystemVersion_gte?: String;
  operatingSystemVersion_contains?: String;
  operatingSystemVersion_not_contains?: String;
  operatingSystemVersion_starts_with?: String;
  operatingSystemVersion_not_starts_with?: String;
  operatingSystemVersion_ends_with?: String;
  operatingSystemVersion_not_ends_with?: String;
  browserName?: String;
  browserName_not?: String;
  browserName_in?: String[] | String;
  browserName_not_in?: String[] | String;
  browserName_lt?: String;
  browserName_lte?: String;
  browserName_gt?: String;
  browserName_gte?: String;
  browserName_contains?: String;
  browserName_not_contains?: String;
  browserName_starts_with?: String;
  browserName_not_starts_with?: String;
  browserName_ends_with?: String;
  browserName_not_ends_with?: String;
  browserVersion?: String;
  browserVersion_not?: String;
  browserVersion_in?: String[] | String;
  browserVersion_not_in?: String[] | String;
  browserVersion_lt?: String;
  browserVersion_lte?: String;
  browserVersion_gt?: String;
  browserVersion_gte?: String;
  browserVersion_contains?: String;
  browserVersion_not_contains?: String;
  browserVersion_starts_with?: String;
  browserVersion_not_starts_with?: String;
  browserVersion_ends_with?: String;
  browserVersion_not_ends_with?: String;
  fingerprint?: String;
  fingerprint_not?: String;
  fingerprint_in?: String[] | String;
  fingerprint_not_in?: String[] | String;
  fingerprint_lt?: String;
  fingerprint_lte?: String;
  fingerprint_gt?: String;
  fingerprint_gte?: String;
  fingerprint_contains?: String;
  fingerprint_not_contains?: String;
  fingerprint_starts_with?: String;
  fingerprint_not_starts_with?: String;
  fingerprint_ends_with?: String;
  fingerprint_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  user?: UserWhereInput;
  AND?: SessionWhereInput[] | SessionWhereInput;
  OR?: SessionWhereInput[] | SessionWhereInput;
  NOT?: SessionWhereInput[] | SessionWhereInput;
}

export interface LogWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  operation?: String;
  operation_not?: String;
  operation_in?: String[] | String;
  operation_not_in?: String[] | String;
  operation_lt?: String;
  operation_lte?: String;
  operation_gt?: String;
  operation_gte?: String;
  operation_contains?: String;
  operation_not_contains?: String;
  operation_starts_with?: String;
  operation_not_starts_with?: String;
  operation_ends_with?: String;
  operation_not_ends_with?: String;
  resource?: String;
  resource_not?: String;
  resource_in?: String[] | String;
  resource_not_in?: String[] | String;
  resource_lt?: String;
  resource_lte?: String;
  resource_gt?: String;
  resource_gte?: String;
  resource_contains?: String;
  resource_not_contains?: String;
  resource_starts_with?: String;
  resource_not_starts_with?: String;
  resource_ends_with?: String;
  resource_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  user?: UserWhereInput;
  AND?: LogWhereInput[] | LogWhereInput;
  OR?: LogWhereInput[] | LogWhereInput;
  NOT?: LogWhereInput[] | LogWhereInput;
}

export type LogWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type SessionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface AccessCreateInput {
  userAssigned: UserCreateOneWithoutAccessInput;
  roles?: AccessCreaterolesInput;
}

export interface UserCreateOneWithoutAccessInput {
  create?: UserCreateWithoutAccessInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutAccessInput {
  enabled?: Boolean;
  hidden?: Boolean;
  totp?: Boolean;
  emailVerified?: Boolean;
  password: String;
  firstName: String;
  lastName: String;
  email: String;
  profilePicture?: String;
  birthday?: DateTimeInput;
  expertises?: UserCreateexpertisesInput;
  crm?: String;
  eCrm?: String;
  signaturePath?: String;
  defaultReports?: UserCreatedefaultReportsInput;
  requiredActions?: UserCreaterequiredActionsInput;
  settings?: SettingsCreateOneInput;
  sessions?: SessionCreateManyWithoutUserInput;
  logs?: LogCreateManyWithoutUserInput;
}

export interface UserCreateexpertisesInput {
  set?: String[] | String;
}

export interface UserCreatedefaultReportsInput {
  set?: String[] | String;
}

export interface UserCreaterequiredActionsInput {
  set?: String[] | String;
}

export interface SettingsCreateOneInput {
  create?: SettingsCreateInput;
}

export interface SettingsCreateInput {
  theme?: ThemePicker;
}

export interface SessionCreateManyWithoutUserInput {
  create?: SessionCreateWithoutUserInput[] | SessionCreateWithoutUserInput;
  connect?: SessionWhereUniqueInput[] | SessionWhereUniqueInput;
}

export interface SessionCreateWithoutUserInput {
  operatingSystemName?: String;
  operatingSystemVersion?: String;
  browserName?: String;
  browserVersion?: String;
  fingerprint?: String;
}

export interface LogCreateManyWithoutUserInput {
  create?: LogCreateWithoutUserInput[] | LogCreateWithoutUserInput;
  connect?: LogWhereUniqueInput[] | LogWhereUniqueInput;
}

export interface LogCreateWithoutUserInput {
  operation: String;
  resource: String;
}

export interface AccessCreaterolesInput {
  set?: String[] | String;
}

export interface AccessUpdateInput {
  userAssigned?: UserUpdateOneRequiredWithoutAccessInput;
  roles?: AccessUpdaterolesInput;
}

export interface UserUpdateOneRequiredWithoutAccessInput {
  create?: UserCreateWithoutAccessInput;
  update?: UserUpdateWithoutAccessDataInput;
  upsert?: UserUpsertWithoutAccessInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutAccessDataInput {
  enabled?: Boolean;
  hidden?: Boolean;
  totp?: Boolean;
  emailVerified?: Boolean;
  password?: String;
  firstName?: String;
  lastName?: String;
  email?: String;
  profilePicture?: String;
  birthday?: DateTimeInput;
  expertises?: UserUpdateexpertisesInput;
  crm?: String;
  eCrm?: String;
  signaturePath?: String;
  defaultReports?: UserUpdatedefaultReportsInput;
  requiredActions?: UserUpdaterequiredActionsInput;
  settings?: SettingsUpdateOneInput;
  sessions?: SessionUpdateManyWithoutUserInput;
  logs?: LogUpdateManyWithoutUserInput;
}

export interface UserUpdateexpertisesInput {
  set?: String[] | String;
}

export interface UserUpdatedefaultReportsInput {
  set?: String[] | String;
}

export interface UserUpdaterequiredActionsInput {
  set?: String[] | String;
}

export interface SettingsUpdateOneInput {
  create?: SettingsCreateInput;
  update?: SettingsUpdateDataInput;
  upsert?: SettingsUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface SettingsUpdateDataInput {
  theme?: ThemePicker;
}

export interface SettingsUpsertNestedInput {
  update: SettingsUpdateDataInput;
  create: SettingsCreateInput;
}

export interface SessionUpdateManyWithoutUserInput {
  create?: SessionCreateWithoutUserInput[] | SessionCreateWithoutUserInput;
  delete?: SessionWhereUniqueInput[] | SessionWhereUniqueInput;
  connect?: SessionWhereUniqueInput[] | SessionWhereUniqueInput;
  set?: SessionWhereUniqueInput[] | SessionWhereUniqueInput;
  disconnect?: SessionWhereUniqueInput[] | SessionWhereUniqueInput;
  update?:
    | SessionUpdateWithWhereUniqueWithoutUserInput[]
    | SessionUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | SessionUpsertWithWhereUniqueWithoutUserInput[]
    | SessionUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: SessionScalarWhereInput[] | SessionScalarWhereInput;
  updateMany?:
    | SessionUpdateManyWithWhereNestedInput[]
    | SessionUpdateManyWithWhereNestedInput;
}

export interface SessionUpdateWithWhereUniqueWithoutUserInput {
  where: SessionWhereUniqueInput;
  data: SessionUpdateWithoutUserDataInput;
}

export interface SessionUpdateWithoutUserDataInput {
  operatingSystemName?: String;
  operatingSystemVersion?: String;
  browserName?: String;
  browserVersion?: String;
  fingerprint?: String;
}

export interface SessionUpsertWithWhereUniqueWithoutUserInput {
  where: SessionWhereUniqueInput;
  update: SessionUpdateWithoutUserDataInput;
  create: SessionCreateWithoutUserInput;
}

export interface SessionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  operatingSystemName?: String;
  operatingSystemName_not?: String;
  operatingSystemName_in?: String[] | String;
  operatingSystemName_not_in?: String[] | String;
  operatingSystemName_lt?: String;
  operatingSystemName_lte?: String;
  operatingSystemName_gt?: String;
  operatingSystemName_gte?: String;
  operatingSystemName_contains?: String;
  operatingSystemName_not_contains?: String;
  operatingSystemName_starts_with?: String;
  operatingSystemName_not_starts_with?: String;
  operatingSystemName_ends_with?: String;
  operatingSystemName_not_ends_with?: String;
  operatingSystemVersion?: String;
  operatingSystemVersion_not?: String;
  operatingSystemVersion_in?: String[] | String;
  operatingSystemVersion_not_in?: String[] | String;
  operatingSystemVersion_lt?: String;
  operatingSystemVersion_lte?: String;
  operatingSystemVersion_gt?: String;
  operatingSystemVersion_gte?: String;
  operatingSystemVersion_contains?: String;
  operatingSystemVersion_not_contains?: String;
  operatingSystemVersion_starts_with?: String;
  operatingSystemVersion_not_starts_with?: String;
  operatingSystemVersion_ends_with?: String;
  operatingSystemVersion_not_ends_with?: String;
  browserName?: String;
  browserName_not?: String;
  browserName_in?: String[] | String;
  browserName_not_in?: String[] | String;
  browserName_lt?: String;
  browserName_lte?: String;
  browserName_gt?: String;
  browserName_gte?: String;
  browserName_contains?: String;
  browserName_not_contains?: String;
  browserName_starts_with?: String;
  browserName_not_starts_with?: String;
  browserName_ends_with?: String;
  browserName_not_ends_with?: String;
  browserVersion?: String;
  browserVersion_not?: String;
  browserVersion_in?: String[] | String;
  browserVersion_not_in?: String[] | String;
  browserVersion_lt?: String;
  browserVersion_lte?: String;
  browserVersion_gt?: String;
  browserVersion_gte?: String;
  browserVersion_contains?: String;
  browserVersion_not_contains?: String;
  browserVersion_starts_with?: String;
  browserVersion_not_starts_with?: String;
  browserVersion_ends_with?: String;
  browserVersion_not_ends_with?: String;
  fingerprint?: String;
  fingerprint_not?: String;
  fingerprint_in?: String[] | String;
  fingerprint_not_in?: String[] | String;
  fingerprint_lt?: String;
  fingerprint_lte?: String;
  fingerprint_gt?: String;
  fingerprint_gte?: String;
  fingerprint_contains?: String;
  fingerprint_not_contains?: String;
  fingerprint_starts_with?: String;
  fingerprint_not_starts_with?: String;
  fingerprint_ends_with?: String;
  fingerprint_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: SessionScalarWhereInput[] | SessionScalarWhereInput;
  OR?: SessionScalarWhereInput[] | SessionScalarWhereInput;
  NOT?: SessionScalarWhereInput[] | SessionScalarWhereInput;
}

export interface SessionUpdateManyWithWhereNestedInput {
  where: SessionScalarWhereInput;
  data: SessionUpdateManyDataInput;
}

export interface SessionUpdateManyDataInput {
  operatingSystemName?: String;
  operatingSystemVersion?: String;
  browserName?: String;
  browserVersion?: String;
  fingerprint?: String;
}

export interface LogUpdateManyWithoutUserInput {
  create?: LogCreateWithoutUserInput[] | LogCreateWithoutUserInput;
  delete?: LogWhereUniqueInput[] | LogWhereUniqueInput;
  connect?: LogWhereUniqueInput[] | LogWhereUniqueInput;
  set?: LogWhereUniqueInput[] | LogWhereUniqueInput;
  disconnect?: LogWhereUniqueInput[] | LogWhereUniqueInput;
  update?:
    | LogUpdateWithWhereUniqueWithoutUserInput[]
    | LogUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | LogUpsertWithWhereUniqueWithoutUserInput[]
    | LogUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: LogScalarWhereInput[] | LogScalarWhereInput;
  updateMany?:
    | LogUpdateManyWithWhereNestedInput[]
    | LogUpdateManyWithWhereNestedInput;
}

export interface LogUpdateWithWhereUniqueWithoutUserInput {
  where: LogWhereUniqueInput;
  data: LogUpdateWithoutUserDataInput;
}

export interface LogUpdateWithoutUserDataInput {
  operation?: String;
  resource?: String;
}

export interface LogUpsertWithWhereUniqueWithoutUserInput {
  where: LogWhereUniqueInput;
  update: LogUpdateWithoutUserDataInput;
  create: LogCreateWithoutUserInput;
}

export interface LogScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  operation?: String;
  operation_not?: String;
  operation_in?: String[] | String;
  operation_not_in?: String[] | String;
  operation_lt?: String;
  operation_lte?: String;
  operation_gt?: String;
  operation_gte?: String;
  operation_contains?: String;
  operation_not_contains?: String;
  operation_starts_with?: String;
  operation_not_starts_with?: String;
  operation_ends_with?: String;
  operation_not_ends_with?: String;
  resource?: String;
  resource_not?: String;
  resource_in?: String[] | String;
  resource_not_in?: String[] | String;
  resource_lt?: String;
  resource_lte?: String;
  resource_gt?: String;
  resource_gte?: String;
  resource_contains?: String;
  resource_not_contains?: String;
  resource_starts_with?: String;
  resource_not_starts_with?: String;
  resource_ends_with?: String;
  resource_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: LogScalarWhereInput[] | LogScalarWhereInput;
  OR?: LogScalarWhereInput[] | LogScalarWhereInput;
  NOT?: LogScalarWhereInput[] | LogScalarWhereInput;
}

export interface LogUpdateManyWithWhereNestedInput {
  where: LogScalarWhereInput;
  data: LogUpdateManyDataInput;
}

export interface LogUpdateManyDataInput {
  operation?: String;
  resource?: String;
}

export interface UserUpsertWithoutAccessInput {
  update: UserUpdateWithoutAccessDataInput;
  create: UserCreateWithoutAccessInput;
}

export interface AccessUpdaterolesInput {
  set?: String[] | String;
}

export interface AccessUpdateManyMutationInput {
  roles?: AccessUpdaterolesInput;
}

export interface LogCreateInput {
  operation: String;
  resource: String;
  user: UserCreateOneWithoutLogsInput;
}

export interface UserCreateOneWithoutLogsInput {
  create?: UserCreateWithoutLogsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutLogsInput {
  enabled?: Boolean;
  hidden?: Boolean;
  totp?: Boolean;
  emailVerified?: Boolean;
  password: String;
  firstName: String;
  lastName: String;
  email: String;
  profilePicture?: String;
  birthday?: DateTimeInput;
  expertises?: UserCreateexpertisesInput;
  access?: AccessCreateManyWithoutUserAssignedInput;
  crm?: String;
  eCrm?: String;
  signaturePath?: String;
  defaultReports?: UserCreatedefaultReportsInput;
  requiredActions?: UserCreaterequiredActionsInput;
  settings?: SettingsCreateOneInput;
  sessions?: SessionCreateManyWithoutUserInput;
}

export interface AccessCreateManyWithoutUserAssignedInput {
  create?:
    | AccessCreateWithoutUserAssignedInput[]
    | AccessCreateWithoutUserAssignedInput;
  connect?: AccessWhereUniqueInput[] | AccessWhereUniqueInput;
}

export interface AccessCreateWithoutUserAssignedInput {
  roles?: AccessCreaterolesInput;
}

export interface LogUpdateInput {
  operation?: String;
  resource?: String;
  user?: UserUpdateOneRequiredWithoutLogsInput;
}

export interface UserUpdateOneRequiredWithoutLogsInput {
  create?: UserCreateWithoutLogsInput;
  update?: UserUpdateWithoutLogsDataInput;
  upsert?: UserUpsertWithoutLogsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutLogsDataInput {
  enabled?: Boolean;
  hidden?: Boolean;
  totp?: Boolean;
  emailVerified?: Boolean;
  password?: String;
  firstName?: String;
  lastName?: String;
  email?: String;
  profilePicture?: String;
  birthday?: DateTimeInput;
  expertises?: UserUpdateexpertisesInput;
  access?: AccessUpdateManyWithoutUserAssignedInput;
  crm?: String;
  eCrm?: String;
  signaturePath?: String;
  defaultReports?: UserUpdatedefaultReportsInput;
  requiredActions?: UserUpdaterequiredActionsInput;
  settings?: SettingsUpdateOneInput;
  sessions?: SessionUpdateManyWithoutUserInput;
}

export interface AccessUpdateManyWithoutUserAssignedInput {
  create?:
    | AccessCreateWithoutUserAssignedInput[]
    | AccessCreateWithoutUserAssignedInput;
  delete?: AccessWhereUniqueInput[] | AccessWhereUniqueInput;
  connect?: AccessWhereUniqueInput[] | AccessWhereUniqueInput;
  set?: AccessWhereUniqueInput[] | AccessWhereUniqueInput;
  disconnect?: AccessWhereUniqueInput[] | AccessWhereUniqueInput;
  update?:
    | AccessUpdateWithWhereUniqueWithoutUserAssignedInput[]
    | AccessUpdateWithWhereUniqueWithoutUserAssignedInput;
  upsert?:
    | AccessUpsertWithWhereUniqueWithoutUserAssignedInput[]
    | AccessUpsertWithWhereUniqueWithoutUserAssignedInput;
  deleteMany?: AccessScalarWhereInput[] | AccessScalarWhereInput;
  updateMany?:
    | AccessUpdateManyWithWhereNestedInput[]
    | AccessUpdateManyWithWhereNestedInput;
}

export interface AccessUpdateWithWhereUniqueWithoutUserAssignedInput {
  where: AccessWhereUniqueInput;
  data: AccessUpdateWithoutUserAssignedDataInput;
}

export interface AccessUpdateWithoutUserAssignedDataInput {
  roles?: AccessUpdaterolesInput;
}

export interface AccessUpsertWithWhereUniqueWithoutUserAssignedInput {
  where: AccessWhereUniqueInput;
  update: AccessUpdateWithoutUserAssignedDataInput;
  create: AccessCreateWithoutUserAssignedInput;
}

export interface AccessScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: AccessScalarWhereInput[] | AccessScalarWhereInput;
  OR?: AccessScalarWhereInput[] | AccessScalarWhereInput;
  NOT?: AccessScalarWhereInput[] | AccessScalarWhereInput;
}

export interface AccessUpdateManyWithWhereNestedInput {
  where: AccessScalarWhereInput;
  data: AccessUpdateManyDataInput;
}

export interface AccessUpdateManyDataInput {
  roles?: AccessUpdaterolesInput;
}

export interface UserUpsertWithoutLogsInput {
  update: UserUpdateWithoutLogsDataInput;
  create: UserCreateWithoutLogsInput;
}

export interface LogUpdateManyMutationInput {
  operation?: String;
  resource?: String;
}

export interface SessionCreateInput {
  operatingSystemName?: String;
  operatingSystemVersion?: String;
  browserName?: String;
  browserVersion?: String;
  fingerprint?: String;
  user?: UserCreateOneWithoutSessionsInput;
}

export interface UserCreateOneWithoutSessionsInput {
  create?: UserCreateWithoutSessionsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutSessionsInput {
  enabled?: Boolean;
  hidden?: Boolean;
  totp?: Boolean;
  emailVerified?: Boolean;
  password: String;
  firstName: String;
  lastName: String;
  email: String;
  profilePicture?: String;
  birthday?: DateTimeInput;
  expertises?: UserCreateexpertisesInput;
  access?: AccessCreateManyWithoutUserAssignedInput;
  crm?: String;
  eCrm?: String;
  signaturePath?: String;
  defaultReports?: UserCreatedefaultReportsInput;
  requiredActions?: UserCreaterequiredActionsInput;
  settings?: SettingsCreateOneInput;
  logs?: LogCreateManyWithoutUserInput;
}

export interface SessionUpdateInput {
  operatingSystemName?: String;
  operatingSystemVersion?: String;
  browserName?: String;
  browserVersion?: String;
  fingerprint?: String;
  user?: UserUpdateOneWithoutSessionsInput;
}

export interface UserUpdateOneWithoutSessionsInput {
  create?: UserCreateWithoutSessionsInput;
  update?: UserUpdateWithoutSessionsDataInput;
  upsert?: UserUpsertWithoutSessionsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutSessionsDataInput {
  enabled?: Boolean;
  hidden?: Boolean;
  totp?: Boolean;
  emailVerified?: Boolean;
  password?: String;
  firstName?: String;
  lastName?: String;
  email?: String;
  profilePicture?: String;
  birthday?: DateTimeInput;
  expertises?: UserUpdateexpertisesInput;
  access?: AccessUpdateManyWithoutUserAssignedInput;
  crm?: String;
  eCrm?: String;
  signaturePath?: String;
  defaultReports?: UserUpdatedefaultReportsInput;
  requiredActions?: UserUpdaterequiredActionsInput;
  settings?: SettingsUpdateOneInput;
  logs?: LogUpdateManyWithoutUserInput;
}

export interface UserUpsertWithoutSessionsInput {
  update: UserUpdateWithoutSessionsDataInput;
  create: UserCreateWithoutSessionsInput;
}

export interface SessionUpdateManyMutationInput {
  operatingSystemName?: String;
  operatingSystemVersion?: String;
  browserName?: String;
  browserVersion?: String;
  fingerprint?: String;
}

export interface SettingsUpdateManyMutationInput {
  theme?: ThemePicker;
}

export interface UserCreateInput {
  enabled?: Boolean;
  hidden?: Boolean;
  totp?: Boolean;
  emailVerified?: Boolean;
  password: String;
  firstName: String;
  lastName: String;
  email: String;
  profilePicture?: String;
  birthday?: DateTimeInput;
  expertises?: UserCreateexpertisesInput;
  access?: AccessCreateManyWithoutUserAssignedInput;
  crm?: String;
  eCrm?: String;
  signaturePath?: String;
  defaultReports?: UserCreatedefaultReportsInput;
  requiredActions?: UserCreaterequiredActionsInput;
  settings?: SettingsCreateOneInput;
  sessions?: SessionCreateManyWithoutUserInput;
  logs?: LogCreateManyWithoutUserInput;
}

export interface UserUpdateInput {
  enabled?: Boolean;
  hidden?: Boolean;
  totp?: Boolean;
  emailVerified?: Boolean;
  password?: String;
  firstName?: String;
  lastName?: String;
  email?: String;
  profilePicture?: String;
  birthday?: DateTimeInput;
  expertises?: UserUpdateexpertisesInput;
  access?: AccessUpdateManyWithoutUserAssignedInput;
  crm?: String;
  eCrm?: String;
  signaturePath?: String;
  defaultReports?: UserUpdatedefaultReportsInput;
  requiredActions?: UserUpdaterequiredActionsInput;
  settings?: SettingsUpdateOneInput;
  sessions?: SessionUpdateManyWithoutUserInput;
  logs?: LogUpdateManyWithoutUserInput;
}

export interface UserUpdateManyMutationInput {
  enabled?: Boolean;
  hidden?: Boolean;
  totp?: Boolean;
  emailVerified?: Boolean;
  password?: String;
  firstName?: String;
  lastName?: String;
  email?: String;
  profilePicture?: String;
  birthday?: DateTimeInput;
  expertises?: UserUpdateexpertisesInput;
  crm?: String;
  eCrm?: String;
  signaturePath?: String;
  defaultReports?: UserUpdatedefaultReportsInput;
  requiredActions?: UserUpdaterequiredActionsInput;
}

export interface AccessSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AccessWhereInput;
  AND?: AccessSubscriptionWhereInput[] | AccessSubscriptionWhereInput;
  OR?: AccessSubscriptionWhereInput[] | AccessSubscriptionWhereInput;
  NOT?: AccessSubscriptionWhereInput[] | AccessSubscriptionWhereInput;
}

export interface LogSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LogWhereInput;
  AND?: LogSubscriptionWhereInput[] | LogSubscriptionWhereInput;
  OR?: LogSubscriptionWhereInput[] | LogSubscriptionWhereInput;
  NOT?: LogSubscriptionWhereInput[] | LogSubscriptionWhereInput;
}

export interface SessionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SessionWhereInput;
  AND?: SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput;
  OR?: SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput;
  NOT?: SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput;
}

export interface SettingsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SettingsWhereInput;
  AND?: SettingsSubscriptionWhereInput[] | SettingsSubscriptionWhereInput;
  OR?: SettingsSubscriptionWhereInput[] | SettingsSubscriptionWhereInput;
  NOT?: SettingsSubscriptionWhereInput[] | SettingsSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Access {
  id: ID_Output;
  roles: String[];
}

export interface AccessPromise extends Promise<Access>, Fragmentable {
  id: () => Promise<ID_Output>;
  userAssigned: <T = UserPromise>() => T;
  roles: () => Promise<String[]>;
}

export interface AccessSubscription
  extends Promise<AsyncIterator<Access>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userAssigned: <T = UserSubscription>() => T;
  roles: () => Promise<AsyncIterator<String[]>>;
}

export interface User {
  id: ID_Output;
  enabled: Boolean;
  hidden: Boolean;
  totp?: Boolean;
  emailVerified: Boolean;
  password: String;
  firstName: String;
  lastName: String;
  email: String;
  profilePicture?: String;
  birthday?: DateTimeOutput;
  expertises: String[];
  crm?: String;
  eCrm?: String;
  signaturePath?: String;
  defaultReports: String[];
  requiredActions: String[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  enabled: () => Promise<Boolean>;
  hidden: () => Promise<Boolean>;
  totp: () => Promise<Boolean>;
  emailVerified: () => Promise<Boolean>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  profilePicture: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  expertises: () => Promise<String[]>;
  access: <T = FragmentableArray<Access>>(args?: {
    where?: AccessWhereInput;
    orderBy?: AccessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  crm: () => Promise<String>;
  eCrm: () => Promise<String>;
  signaturePath: () => Promise<String>;
  defaultReports: () => Promise<String[]>;
  requiredActions: () => Promise<String[]>;
  settings: <T = SettingsPromise>() => T;
  sessions: <T = FragmentableArray<Session>>(args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  logs: <T = FragmentableArray<Log>>(args?: {
    where?: LogWhereInput;
    orderBy?: LogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  enabled: () => Promise<AsyncIterator<Boolean>>;
  hidden: () => Promise<AsyncIterator<Boolean>>;
  totp: () => Promise<AsyncIterator<Boolean>>;
  emailVerified: () => Promise<AsyncIterator<Boolean>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  profilePicture: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  expertises: () => Promise<AsyncIterator<String[]>>;
  access: <T = Promise<AsyncIterator<AccessSubscription>>>(args?: {
    where?: AccessWhereInput;
    orderBy?: AccessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  crm: () => Promise<AsyncIterator<String>>;
  eCrm: () => Promise<AsyncIterator<String>>;
  signaturePath: () => Promise<AsyncIterator<String>>;
  defaultReports: () => Promise<AsyncIterator<String[]>>;
  requiredActions: () => Promise<AsyncIterator<String[]>>;
  settings: <T = SettingsSubscription>() => T;
  sessions: <T = Promise<AsyncIterator<SessionSubscription>>>(args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  logs: <T = Promise<AsyncIterator<LogSubscription>>>(args?: {
    where?: LogWhereInput;
    orderBy?: LogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Settings {
  theme?: ThemePicker;
}

export interface SettingsPromise extends Promise<Settings>, Fragmentable {
  theme: () => Promise<ThemePicker>;
}

export interface SettingsSubscription
  extends Promise<AsyncIterator<Settings>>,
    Fragmentable {
  theme: () => Promise<AsyncIterator<ThemePicker>>;
}

export interface Session {
  id: ID_Output;
  operatingSystemName?: String;
  operatingSystemVersion?: String;
  browserName?: String;
  browserVersion?: String;
  fingerprint?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SessionPromise extends Promise<Session>, Fragmentable {
  id: () => Promise<ID_Output>;
  operatingSystemName: () => Promise<String>;
  operatingSystemVersion: () => Promise<String>;
  browserName: () => Promise<String>;
  browserVersion: () => Promise<String>;
  fingerprint: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
}

export interface SessionSubscription
  extends Promise<AsyncIterator<Session>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  operatingSystemName: () => Promise<AsyncIterator<String>>;
  operatingSystemVersion: () => Promise<AsyncIterator<String>>;
  browserName: () => Promise<AsyncIterator<String>>;
  browserVersion: () => Promise<AsyncIterator<String>>;
  fingerprint: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
}

export interface Log {
  id: ID_Output;
  operation: String;
  resource: String;
  createdAt: DateTimeOutput;
}

export interface LogPromise extends Promise<Log>, Fragmentable {
  id: () => Promise<ID_Output>;
  operation: () => Promise<String>;
  resource: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
}

export interface LogSubscription
  extends Promise<AsyncIterator<Log>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  operation: () => Promise<AsyncIterator<String>>;
  resource: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
}

export interface AccessConnection {
  pageInfo: PageInfo;
  edges: AccessEdge[];
}

export interface AccessConnectionPromise
  extends Promise<AccessConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AccessEdge>>() => T;
  aggregate: <T = AggregateAccessPromise>() => T;
}

export interface AccessConnectionSubscription
  extends Promise<AsyncIterator<AccessConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AccessEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAccessSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AccessEdge {
  node: Access;
  cursor: String;
}

export interface AccessEdgePromise extends Promise<AccessEdge>, Fragmentable {
  node: <T = AccessPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AccessEdgeSubscription
  extends Promise<AsyncIterator<AccessEdge>>,
    Fragmentable {
  node: <T = AccessSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAccess {
  count: Int;
}

export interface AggregateAccessPromise
  extends Promise<AggregateAccess>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAccessSubscription
  extends Promise<AsyncIterator<AggregateAccess>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LogConnection {
  pageInfo: PageInfo;
  edges: LogEdge[];
}

export interface LogConnectionPromise
  extends Promise<LogConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LogEdge>>() => T;
  aggregate: <T = AggregateLogPromise>() => T;
}

export interface LogConnectionSubscription
  extends Promise<AsyncIterator<LogConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLogSubscription>() => T;
}

export interface LogEdge {
  node: Log;
  cursor: String;
}

export interface LogEdgePromise extends Promise<LogEdge>, Fragmentable {
  node: <T = LogPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LogEdgeSubscription
  extends Promise<AsyncIterator<LogEdge>>,
    Fragmentable {
  node: <T = LogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLog {
  count: Int;
}

export interface AggregateLogPromise
  extends Promise<AggregateLog>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLogSubscription
  extends Promise<AsyncIterator<AggregateLog>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SessionConnection {
  pageInfo: PageInfo;
  edges: SessionEdge[];
}

export interface SessionConnectionPromise
  extends Promise<SessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SessionEdge>>() => T;
  aggregate: <T = AggregateSessionPromise>() => T;
}

export interface SessionConnectionSubscription
  extends Promise<AsyncIterator<SessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSessionSubscription>() => T;
}

export interface SessionEdge {
  node: Session;
  cursor: String;
}

export interface SessionEdgePromise extends Promise<SessionEdge>, Fragmentable {
  node: <T = SessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SessionEdgeSubscription
  extends Promise<AsyncIterator<SessionEdge>>,
    Fragmentable {
  node: <T = SessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSession {
  count: Int;
}

export interface AggregateSessionPromise
  extends Promise<AggregateSession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSessionSubscription
  extends Promise<AsyncIterator<AggregateSession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SettingsConnection {
  pageInfo: PageInfo;
  edges: SettingsEdge[];
}

export interface SettingsConnectionPromise
  extends Promise<SettingsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SettingsEdge>>() => T;
  aggregate: <T = AggregateSettingsPromise>() => T;
}

export interface SettingsConnectionSubscription
  extends Promise<AsyncIterator<SettingsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SettingsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSettingsSubscription>() => T;
}

export interface SettingsEdge {
  node: Settings;
  cursor: String;
}

export interface SettingsEdgePromise
  extends Promise<SettingsEdge>,
    Fragmentable {
  node: <T = SettingsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SettingsEdgeSubscription
  extends Promise<AsyncIterator<SettingsEdge>>,
    Fragmentable {
  node: <T = SettingsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSettings {
  count: Int;
}

export interface AggregateSettingsPromise
  extends Promise<AggregateSettings>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSettingsSubscription
  extends Promise<AsyncIterator<AggregateSettings>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AccessSubscriptionPayload {
  mutation: MutationType;
  node: Access;
  updatedFields: String[];
  previousValues: AccessPreviousValues;
}

export interface AccessSubscriptionPayloadPromise
  extends Promise<AccessSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AccessPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AccessPreviousValuesPromise>() => T;
}

export interface AccessSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AccessSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AccessSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AccessPreviousValuesSubscription>() => T;
}

export interface AccessPreviousValues {
  id: ID_Output;
  roles: String[];
}

export interface AccessPreviousValuesPromise
  extends Promise<AccessPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  roles: () => Promise<String[]>;
}

export interface AccessPreviousValuesSubscription
  extends Promise<AsyncIterator<AccessPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  roles: () => Promise<AsyncIterator<String[]>>;
}

export interface LogSubscriptionPayload {
  mutation: MutationType;
  node: Log;
  updatedFields: String[];
  previousValues: LogPreviousValues;
}

export interface LogSubscriptionPayloadPromise
  extends Promise<LogSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LogPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LogPreviousValuesPromise>() => T;
}

export interface LogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LogSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LogPreviousValuesSubscription>() => T;
}

export interface LogPreviousValues {
  id: ID_Output;
  operation: String;
  resource: String;
  createdAt: DateTimeOutput;
}

export interface LogPreviousValuesPromise
  extends Promise<LogPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  operation: () => Promise<String>;
  resource: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface LogPreviousValuesSubscription
  extends Promise<AsyncIterator<LogPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  operation: () => Promise<AsyncIterator<String>>;
  resource: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SessionSubscriptionPayload {
  mutation: MutationType;
  node: Session;
  updatedFields: String[];
  previousValues: SessionPreviousValues;
}

export interface SessionSubscriptionPayloadPromise
  extends Promise<SessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SessionPreviousValuesPromise>() => T;
}

export interface SessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SessionPreviousValuesSubscription>() => T;
}

export interface SessionPreviousValues {
  id: ID_Output;
  operatingSystemName?: String;
  operatingSystemVersion?: String;
  browserName?: String;
  browserVersion?: String;
  fingerprint?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SessionPreviousValuesPromise
  extends Promise<SessionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  operatingSystemName: () => Promise<String>;
  operatingSystemVersion: () => Promise<String>;
  browserName: () => Promise<String>;
  browserVersion: () => Promise<String>;
  fingerprint: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SessionPreviousValuesSubscription
  extends Promise<AsyncIterator<SessionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  operatingSystemName: () => Promise<AsyncIterator<String>>;
  operatingSystemVersion: () => Promise<AsyncIterator<String>>;
  browserName: () => Promise<AsyncIterator<String>>;
  browserVersion: () => Promise<AsyncIterator<String>>;
  fingerprint: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SettingsSubscriptionPayload {
  mutation: MutationType;
  node: Settings;
  updatedFields: String[];
  previousValues: SettingsPreviousValues;
}

export interface SettingsSubscriptionPayloadPromise
  extends Promise<SettingsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SettingsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SettingsPreviousValuesPromise>() => T;
}

export interface SettingsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SettingsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SettingsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SettingsPreviousValuesSubscription>() => T;
}

export interface SettingsPreviousValues {
  theme?: ThemePicker;
}

export interface SettingsPreviousValuesPromise
  extends Promise<SettingsPreviousValues>,
    Fragmentable {
  theme: () => Promise<ThemePicker>;
}

export interface SettingsPreviousValuesSubscription
  extends Promise<AsyncIterator<SettingsPreviousValues>>,
    Fragmentable {
  theme: () => Promise<AsyncIterator<ThemePicker>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  enabled: Boolean;
  hidden: Boolean;
  totp?: Boolean;
  emailVerified: Boolean;
  password: String;
  firstName: String;
  lastName: String;
  email: String;
  profilePicture?: String;
  birthday?: DateTimeOutput;
  expertises: String[];
  crm?: String;
  eCrm?: String;
  signaturePath?: String;
  defaultReports: String[];
  requiredActions: String[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  enabled: () => Promise<Boolean>;
  hidden: () => Promise<Boolean>;
  totp: () => Promise<Boolean>;
  emailVerified: () => Promise<Boolean>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  profilePicture: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  expertises: () => Promise<String[]>;
  crm: () => Promise<String>;
  eCrm: () => Promise<String>;
  signaturePath: () => Promise<String>;
  defaultReports: () => Promise<String[]>;
  requiredActions: () => Promise<String[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  enabled: () => Promise<AsyncIterator<Boolean>>;
  hidden: () => Promise<AsyncIterator<Boolean>>;
  totp: () => Promise<AsyncIterator<Boolean>>;
  emailVerified: () => Promise<AsyncIterator<Boolean>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  profilePicture: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  expertises: () => Promise<AsyncIterator<String[]>>;
  crm: () => Promise<AsyncIterator<String>>;
  eCrm: () => Promise<AsyncIterator<String>>;
  signaturePath: () => Promise<AsyncIterator<String>>;
  defaultReports: () => Promise<AsyncIterator<String[]>>;
  requiredActions: () => Promise<AsyncIterator<String[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Access",
    embedded: false
  },
  {
    name: "Log",
    embedded: false
  },
  {
    name: "Session",
    embedded: false
  },
  {
    name: "Settings",
    embedded: false
  },
  {
    name: "ThemePicker",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
